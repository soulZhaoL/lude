# 多阶段优化系统语义化策略实现方案

## 一、问题诊断总结

### 当前实现的三大核心缺陷

1. **索引选择破坏语义关联**（第144-145行）
   - Optuna只看到无意义的索引0,1,2...
   - TPE无法学习因子组合的内在规律
   - 导致优化过程退化为随机搜索

2. **动态参数命名导致空间不稳定**（第150-151行）
   - 不同组合产生不同参数名（factor0_weight vs factor1_weight）
   - TPE无法在试验间建立关联
   - 每次试验都像从头开始

3. **离散权重限制优化精度**（第150行）
   - 权重只能是1,2,3,4,5五个离散值
   - 精调阶段无法找到最优权重配比
   - 限制了最终性能上限

## 二、语义化策略设计

### 2.1 核心设计理念

将无意义的索引选择转换为有业务含义的投资策略选择，让Optuna能够理解每个选择的语义含义。

### 2.2 投资策略分类体系

基于可转债投资的业务特点，设计五大核心策略：

```python
INVESTMENT_STRATEGIES = {
    "value": {
        "name": "价值投资策略",
        "description": "关注低溢价率、低价格的价值型可转债",
        "core_factors": ["conv_prem", "dblow", "close", "bond_prem", "pure_value"],
        "auxiliary_pool": ["theory_conv_prem", "mod_conv_prem", "ytm"],
        "weight_range": (1.0, 3.0),  # 核心因子权重范围
        "aux_weight_range": (0.3, 1.0)  # 辅助因子权重范围
    },
    
    "growth": {
        "name": "成长投资策略",
        "description": "关注高转股价值、正股成长性强的可转债",
        "core_factors": ["conv_value", "close_stk", "pe_ttm", "pb", "total_mv"],
        "auxiliary_pool": ["circ_mv", "ps_ttm", "amount_stk"],
        "weight_range": (1.0, 3.0),
        "aux_weight_range": (0.3, 1.0)
    },
    
    "balanced": {
        "name": "均衡配置策略",
        "description": "平衡价值与成长，构建稳健组合",
        "core_factors": ["conv_prem", "close", "conv_value", "pe_ttm", "dblow"],
        "auxiliary_pool": ["pb", "bond_prem", "theory_value"],
        "weight_range": (0.8, 2.5),
        "aux_weight_range": (0.4, 1.2)
    },
    
    "momentum": {
        "name": "动量交易策略",
        "description": "基于技术指标和市场动量进行交易",
        "core_factors": ["pct_chg_5", "bias_5", "volatility", "turnover_5", "alpha_pct_chg_5"],
        "auxiliary_pool": ["pct_chg", "turnover", "vol_5", "amount_5"],
        "weight_range": (1.0, 2.5),
        "aux_weight_range": (0.3, 0.8)
    },
    
    "contrarian": {
        "name": "逆向投资策略",
        "description": "寻找被市场低估的反向投资机会",
        "core_factors": ["redeem_price_rate", "left_years", "ytm", "redeem_remain_days"],
        "auxiliary_pool": ["debt_to_assets", "dv_ratio", "issue_size"],
        "weight_range": (0.8, 2.0),
        "aux_weight_range": (0.3, 0.7)
    },
    
    "liquidity": {
        "name": "流动性策略",
        "description": "关注成交活跃、流动性好的可转债",
        "core_factors": ["amount", "vol", "turnover", "remain_size", "cap_mv_rate"],
        "auxiliary_pool": ["amount_5", "vol_5", "turnover_5"],
        "weight_range": (1.0, 2.5),
        "aux_weight_range": (0.4, 1.0)
    }
}
```

### 2.3 策略混合机制

允许策略之间的混合，提高灵活性：

```python
def create_semantic_objective_function(df, factors, args, all_filter_conditions=None):
    """创建语义化的目标函数"""
    
    def objective(trial):
        # 1. 选择主策略
        primary_strategy = trial.suggest_categorical(
            "primary_strategy", 
            list(INVESTMENT_STRATEGIES.keys())
        )
        
        # 2. 决定是否混合策略
        use_mixed_strategy = trial.suggest_categorical("use_mixed_strategy", [True, False])
        
        if use_mixed_strategy:
            # 选择次要策略（排除主策略）
            available_secondary = [s for s in INVESTMENT_STRATEGIES.keys() 
                                  if s != primary_strategy]
            secondary_strategy = trial.suggest_categorical(
                "secondary_strategy", 
                available_secondary
            )
            
            # 混合比例
            primary_weight = trial.suggest_float("primary_mix_ratio", 0.6, 0.9, step=0.05)
            secondary_weight = 1 - primary_weight
        else:
            secondary_strategy = None
            primary_weight = 1.0
            secondary_weight = 0.0
        
        # 3. 构建因子集合
        rank_factors = []
        
        # 添加主策略因子
        primary_config = INVESTMENT_STRATEGIES[primary_strategy]
        for factor in primary_config["core_factors"]:
            weight = trial.suggest_float(
                f"weight_{primary_strategy}_{factor}", 
                primary_config["weight_range"][0] * primary_weight,
                primary_config["weight_range"][1] * primary_weight,
                step=0.1
            )
            ascending = trial.suggest_categorical(
                f"ascending_{primary_strategy}_{factor}", 
                [True, False]
            )
            rank_factors.append({
                "name": factor, 
                "weight": weight, 
                "ascending": ascending,
                "source": primary_strategy
            })
        
        # 添加次要策略因子（如果有）
        if secondary_strategy:
            secondary_config = INVESTMENT_STRATEGIES[secondary_strategy]
            # 只选择部分核心因子避免过多
            n_secondary_factors = trial.suggest_int("n_secondary_factors", 2, 3)
            selected_secondary = trial.suggest_categorical(
                "selected_secondary_factors",
                secondary_config["core_factors"][:n_secondary_factors]
            )
            
            for factor in selected_secondary:
                if factor not in [f["name"] for f in rank_factors]:  # 避免重复
                    weight = trial.suggest_float(
                        f"weight_{secondary_strategy}_{factor}",
                        secondary_config["weight_range"][0] * secondary_weight,
                        secondary_config["weight_range"][1] * secondary_weight,
                        step=0.1
                    )
                    ascending = trial.suggest_categorical(
                        f"ascending_{secondary_strategy}_{factor}",
                        [True, False]
                    )
                    rank_factors.append({
                        "name": factor,
                        "weight": weight,
                        "ascending": ascending,
                        "source": secondary_strategy
                    })
        
        # 4. 添加辅助因子（可选）
        enable_auxiliary = trial.suggest_categorical("enable_auxiliary", [True, False])
        if enable_auxiliary:
            # 从主策略的辅助池中选择
            n_auxiliary = trial.suggest_int("n_auxiliary_factors", 1, 2)
            auxiliary_pool = primary_config["auxiliary_pool"]
            
            for i in range(min(n_auxiliary, len(auxiliary_pool))):
                aux_factor = trial.suggest_categorical(
                    f"aux_factor_{i}",
                    auxiliary_pool
                )
                if aux_factor not in [f["name"] for f in rank_factors]:
                    aux_weight = trial.suggest_float(
                        f"aux_weight_{aux_factor}",
                        primary_config["aux_weight_range"][0],
                        primary_config["aux_weight_range"][1],
                        step=0.05
                    )
                    aux_ascending = trial.suggest_categorical(
                        f"aux_ascending_{aux_factor}",
                        [True, False]
                    )
                    rank_factors.append({
                        "name": aux_factor,
                        "weight": aux_weight,
                        "ascending": aux_ascending,
                        "source": "auxiliary"
                    })
        
        # 5. 计算CAGR
        try:
            cagr = calculate_bonds_cagr(
                df,
                start_date=args.start_date,
                end_date=args.end_date,
                hold_num=args.hold_num,
                min_price=args.price_min,
                max_price=args.price_max,
                rank_factors=rank_factors,
                filter_conditions=selected_filter_conditions,
                check_overfitting=True,
                verbose_overfitting=False
            )
            
            # 保存策略信息
            trial.set_user_attr("primary_strategy", primary_strategy)
            trial.set_user_attr("secondary_strategy", secondary_strategy)
            trial.set_user_attr("rank_factors", rank_factors)
            trial.set_user_attr("filter_conditions", selected_filter_conditions)
            
            return cagr
            
        except ValueError as e:
            if "过拟合" in str(e) or "无符合条件" in str(e):
                raise optuna.exceptions.TrialPruned()
            else:
                raise
    
    return objective
```

## 三、排除因子语义化改造

### 3.1 排除策略设计

同样采用语义化方式处理排除因子：

```python
FILTER_STRATEGIES = {
    "conservative": {
        "name": "保守过滤",
        "description": "严格过滤高风险标的",
        "filters": [
            {"factor": "conv_prem", "operator": "<=", "value": 15.0},
            {"factor": "dblow", "operator": "<=", "value": 130.0},
            {"factor": "left_years", "operator": ">=", "value": 1.0},
            {"factor": "redeem_price_rate", "operator": "<=", "value": 120.0}
        ]
    },
    
    "moderate": {
        "name": "适度过滤",
        "description": "平衡风险与收益",
        "filters": [
            {"factor": "conv_prem", "operator": "<=", "value": 25.0},
            {"factor": "amount", "operator": ">=", "value": 500.0},
            {"factor": "volatility", "operator": "<=", "value": 0.35}
        ]
    },
    
    "aggressive": {
        "name": "激进过滤",
        "description": "宽松过滤以获取更多机会",
        "filters": [
            {"factor": "conv_prem", "operator": "<=", "value": 40.0},
            {"factor": "amount", "operator": ">=", "value": 100.0}
        ]
    },
    
    "liquidity_focused": {
        "name": "流动性过滤",
        "description": "重点关注流动性",
        "filters": [
            {"factor": "amount", "operator": ">=", "value": 1000.0},
            {"factor": "turnover", "operator": ">=", "value": 5.0},
            {"factor": "remain_size", "operator": ">=", "value": 1.0}
        ]
    },
    
    "none": {
        "name": "无过滤",
        "description": "不使用排除条件",
        "filters": []
    }
}

def select_filter_conditions(trial):
    """选择排除条件"""
    
    # 1. 选择过滤策略
    filter_strategy = trial.suggest_categorical(
        "filter_strategy",
        list(FILTER_STRATEGIES.keys())
    )
    
    strategy_config = FILTER_STRATEGIES[filter_strategy]
    base_filters = strategy_config["filters"].copy()
    
    # 2. 允许微调过滤参数
    if filter_strategy != "none":
        tune_filters = trial.suggest_categorical("tune_filters", [True, False])
        
        if tune_filters:
            tuned_filters = []
            for i, filter_rule in enumerate(base_filters):
                # 允许调整阈值
                factor = filter_rule["factor"]
                operator = filter_rule["operator"]
                base_value = filter_rule["value"]
                
                # 根据因子类型设置调整范围
                if factor in ["conv_prem", "dblow", "redeem_price_rate"]:
                    # 百分比类因子
                    adjusted_value = trial.suggest_float(
                        f"filter_{factor}_value",
                        base_value * 0.7,
                        base_value * 1.3,
                        step=1.0
                    )
                elif factor in ["amount", "turnover", "remain_size"]:
                    # 数量类因子
                    adjusted_value = trial.suggest_float(
                        f"filter_{factor}_value",
                        base_value * 0.5,
                        base_value * 2.0,
                        step=base_value * 0.1
                    )
                else:
                    adjusted_value = base_value
                
                tuned_filters.append({
                    "factor": factor,
                    "operator": operator,
                    "value": adjusted_value
                })
            
            return tuned_filters
    
    return base_filters
```

## 四、实施步骤

### 4.1 第一步：创建策略配置文件

```yaml
# strategy_config.yaml
investment_strategies:
  value:
    name: "价值投资策略"
    core_factors: ["conv_prem", "dblow", "close", "bond_prem", "pure_value"]
    auxiliary_pool: ["theory_conv_prem", "mod_conv_prem", "ytm"]
    weight_range: [1.0, 3.0]
    aux_weight_range: [0.3, 1.0]
  
  growth:
    name: "成长投资策略"
    core_factors: ["conv_value", "close_stk", "pe_ttm", "pb", "total_mv"]
    auxiliary_pool: ["circ_mv", "ps_ttm", "amount_stk"]
    weight_range: [1.0, 3.0]
    aux_weight_range: [0.3, 1.0]
  
  # ... 其他策略配置

filter_strategies:
  conservative:
    name: "保守过滤"
    filters:
      - {factor: "conv_prem", operator: "<=", value: 15.0}
      - {factor: "dblow", operator: "<=", value: 130.0}
      - {factor: "left_years", operator: ">=", value: 1.0}
  
  # ... 其他过滤策略
```

### 4.2 第二步：修改objective函数

1. 替换144-154行的索引选择逻辑
2. 实现语义化策略选择
3. 使用固定参数名确保空间稳定
4. 采用连续权重参数

### 4.3 第三步：修改第一阶段和第二阶段

```python
def run_multistage_optimization(df, factors, args):
    """运行多阶段优化"""
    
    # 第一阶段：探索不同策略（70% trials）
    logger.info("========== 第一阶段：策略探索 ==========")
    
    # 不再需要生成combinations，直接使用语义化目标函数
    objective_func = create_semantic_objective_function(
        df, factors, args, all_filter_conditions=None
    )
    
    # 创建第一阶段study
    first_stage_study = optuna.create_study(
        study_name=f"{args.study_name}_stage1",
        sampler=optuna.samplers.TPESampler(
            n_startup_trials=max(100, int(args.n_trials * 0.15)),
            n_ei_candidates=50,
            multivariate=True,
            group=True
        ),
        direction="maximize"
    )
    
    n_trials_first = int(args.n_trials * 0.7)
    first_stage_study.optimize(objective_func, n_trials=n_trials_first)
    
    # 第二阶段：策略精调（30% trials）
    logger.info("========== 第二阶段：策略精调 ==========")
    
    # 获取第一阶段最佳策略
    best_strategies = analyze_best_strategies(first_stage_study)
    
    # 创建精调目标函数（限制在最佳策略范围内）
    refined_objective = create_refined_objective_function(
        df, best_strategies, args
    )
    
    second_stage_study = optuna.create_study(
        study_name=f"{args.study_name}_stage2",
        sampler=optuna.samplers.TPESampler(
            n_startup_trials=10,
            n_ei_candidates=24,
            multivariate=True,
            consider_prior=True
        ),
        direction="maximize"
    )
    
    n_trials_second = int(args.n_trials * 0.3)
    second_stage_study.optimize(refined_objective, n_trials=n_trials_second)
    
    return first_stage_study, second_stage_study
```

## 五、预期效果

### 5.1 性能提升

| 指标 | 当前值 | 改进后 | 提升幅度 |
|------|--------|--------|----------|
| 参数空间维度 | 50+ | 12-15 | 降低70% |
| 收敛速度 | 基准 | 3-5倍 | 300-500% |
| 最终CAGR | 基准 | +5-10% | 5-10% |
| 参数空间复杂度 | O(10^12) | O(10^4) | 降低8个数量级 |
| TPE学习效率 | 极低 | 高 | 显著提升 |

### 5.2 质量改进

1. **参数空间稳定性**：固定参数名，TPE可以有效学习
2. **语义可解释性**：每个试验都有明确的投资策略含义
3. **优化精度**：连续权重参数允许精细调节
4. **收敛速度**：语义化选择大幅减少无效探索

## 六、风险控制

### 6.1 兼容性保证

```python
def create_objective_function(df, combinations, args, **kwargs):
    """兼容性包装函数"""
    
    use_semantic = args.get("use_semantic_strategy", False)
    
    if use_semantic:
        # 使用新的语义化策略
        return create_semantic_objective_function(df, None, args, **kwargs)
    else:
        # 保持原有逻辑
        return create_optimized_objective_function(df, combinations, args, **kwargs)
```

### 6.2 渐进式迁移

1. 先在测试环境验证
2. A/B测试对比效果
3. 逐步切换生产环境
4. 保留回滚机制

## 七、测试验证

### 7.1 单元测试

```python
def test_semantic_strategy():
    """测试语义化策略"""
    
    # 1. 测试策略选择
    study = optuna.create_study()
    objective = create_semantic_objective_function(df, factors, args)
    study.optimize(objective, n_trials=10)
    
    # 2. 验证参数空间稳定性
    assert all("primary_strategy" in t.params for t in study.trials)
    
    # 3. 验证权重连续性
    weights = [p for p in study.trials[0].params if "weight" in p]
    assert all(isinstance(study.trials[0].params[w], float) for w in weights)
```

### 7.2 性能基准测试

```python
def benchmark_convergence():
    """对比收敛速度"""
    
    # 运行原始版本
    old_study = run_old_optimization(n_trials=1000)
    old_best = old_study.best_value
    old_convergence = get_convergence_curve(old_study)
    
    # 运行语义化版本
    new_study = run_semantic_optimization(n_trials=1000)
    new_best = new_study.best_value
    new_convergence = get_convergence_curve(new_study)
    
    # 分析结果
    print(f"CAGR提升: {(new_best - old_best) / old_best * 100:.2f}%")
    print(f"收敛速度提升: {calculate_speedup(old_convergence, new_convergence):.2f}x")
```

## 八、实施时间表

| 阶段 | 任务 | 时间 | 交付物 |
|------|------|------|--------|
| 第1天 | 创建策略配置体系 | 4小时 | strategy_config.yaml |
| 第2天 | 实现语义化objective | 6小时 | semantic_objective.py |
| 第3天 | 集成测试 | 4小时 | 测试报告 |
| 第4天 | 性能优化 | 4小时 | 优化版本 |
| 第5天 | 生产部署 | 2小时 | 部署文档 |

## 九、总结

通过语义化策略改造，我们将实现：

1. **参数空间稳定化**：从动态变化到固定结构
2. **搜索效率提升**：从盲目探索到有向搜索
3. **优化精度增强**：从离散权重到连续调节
4. **业务语义清晰**：从数字索引到策略名称

这个方案不仅解决了技术问题，还让整个系统更容易理解和维护。